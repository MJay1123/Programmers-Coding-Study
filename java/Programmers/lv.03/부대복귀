강철부대의 각 부대원이 여러 지역에 뿔뿔이 흩어져 특수 임무를 수행 중입니다.
지도에서 강철부대가 위치한 지역을 포함한 각 지역은 유일한 번호로 구분되며, 두 지역 간의 길을 통과하는 데 걸리는 시간은 모두 1로 동일합니다.
임무를 수행한 각 부대원은 지도 정보를 이용하여 최단시간에 부대로 복귀하고자 합니다. 다만 적군의 방해로 인해, 임무의 시작 때와 다르게 되돌아오는 경로가 없어져 복귀가 불가능한 부대원도 있을 수 있습니다.

강철부대가 위치한 지역을 포함한 총지역의 수 n, 두 지역을 왕복할 수 있는 길 정보를 담은 2차원 정수 배열 roads,
각 부대원이 위치한 서로 다른 지역들을 나타내는 정수 배열 sources, 강철부대의 지역 destination이 주어졌을 때,
주어진 sources의 원소 순서대로 강철부대로 복귀할 수 있는 최단시간을 담은 배열을 return하는 solution 함수를 완성해주세요. 복귀가 불가능한 경우 해당 부대원의 최단시간은 -1입니다.

제한사항
3 ≤ n ≤ 100,000
각 지역은 정수 1부터 n까지의 번호로 구분됩니다.
2 ≤ roads의 길이 ≤ 500,000
roads의 원소의 길이 = 2
roads의 원소는 [a, b] 형태로 두 지역 a, b가 서로 왕복할 수 있음을 의미합니다.(1 ≤ a, b ≤ n, a ≠ b)
동일한 정보가 중복해서 주어지지 않습니다.
동일한 [a, b]가 중복해서 주어지지 않습니다.
[a, b]가 있다면 [b, a]는 주어지지 않습니다.
1 ≤ sources의 길이 ≤ 500
1 ≤ sources[i] ≤ n
1 ≤ destination ≤ n
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
import java.util.*;
class Solution {
    static boolean[] visited;
    static int[] distanceArray;
    static List<List<Integer>> roadMap;
    static class Node implements Comparable<Node>{
        int number;
        int distance;
        public Node(int number, int distance){
            this.number = number;
            this.distance = distance;
        }
        @Override
        public int compareTo(Node n){
            return this.distance - n.distance;
        }
    }
    public int[] solution(int n, int[][] roads, int[] sources, int destination) {
        roadMap = new ArrayList<>();
        for(int i=0; i<=n; i++){
            List<Integer> list = new ArrayList<>();
            roadMap.add(list);
        }
        for(int i=0; i<roads.length; i++){
            int num1 = roads[i][0];
            int num2 = roads[i][1];
            roadMap.get(num1).add(num2);
            roadMap.get(num2).add(num1);
        }
        visited = new boolean[n+1];
        distanceArray = new int[n+1];
        for(int i=0; i<=n; i++){
            distanceArray[i] = 500000 * 500;
        }
        PriorityQueue<Node> pq = new PriorityQueue<>();
        Node start = new Node(destination, 0);
        pq.offer(start);
        visited[destination] = true;
        distanceArray[destination] = 0;
        while(!pq.isEmpty()){
            Node prev = pq.poll();
            for(int i : roadMap.get(prev.number)){
                if(!visited[i]){
                    int minDistance = Math.min(distanceArray[i], prev.distance + 1);
                    Node node = new Node(i, minDistance);
                    pq.offer(node);
                    visited[i] = true;
                    distanceArray[i] = minDistance;
                }
            }
        }
        int[] answer = new int[sources.length];
        for(int i=0; i<sources.length; i++){
            if(distanceArray[sources[i]] == 250000000){
                answer[i] = -1;
            } else {
                answer[i] = distanceArray[sources[i]];
            }
        }
        return answer;
    }
}
